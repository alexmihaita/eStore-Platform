1. CERINTA NUMARUL 1->Ierarhia Produs am rezolvat-o fix cum am invatat la curs si nu am intampinat probleme prea mari, singura chestie care m-a pus pe ganduri a fost cea cand a trebuit sa facem reducerea unui 'discountedproduct', dar dupa discutiile de pe forum, mi-am dat seama cum se face. Debugging-ul l-am facut separat, creand un proiect nou cu fiecare clasa in parte, si ruland obisnuit codul, fara checker.

Ierarhia User am rezolvat-o aproximativ la fel ca prima, fara sa intampin probleme.

Ierarhia ShoppingCart nu a fost nici ea foarte greu de implementat, desi a trebuit sa mai citesc un pic inainte de a ma apuca de ea, capitolul de STL din curs pentru a intelege exact ce este un map. Apoi, toate metodele le-am implementat asa cum am invatat pe parcursul semestrului.

2. CERINTA NUMARUL 2-> La ierarhia Server, a fost putin mai mult de ganit. In primul rand, la metoda set__UserID__ProductsCart__(), am declarat un obiect pointer de tip shopping cart, iar apoi am parcurs lista de useri, introducand in fiecare map de useri, ID-ul lor si shopping cartul. In rest, celelalte metode mi s-au parut la fel de simplu de implementat ca si cele de la punctele precedente.

3. CERINTA NUMARUL 3-> La QuerySolver, lucrurile au stat putin diferit, deoarece aici a trebuit sa gandesc un pic rezolvarea cerintelor, mai ales la ultimele subpuncte. 
La a), am reusit sa fac prin doua metode: prima, cea pe care am si lasat-o necomentata, parcurge lista de produs cu ajutorul serverului creat anterior si verifica tipul produsului si categoria, apoi baga acest produs nou gasit intr-o lista nou creata, pe care o si afisam. In cea de-a doua metoda, am facut o copie a listei de produse, si cum gaseam un produs dorit, care sa indeplineasca acele conditii, il stergeam din lista si apoi il afisam. Am preferat sa las in codul functional doar prima metoda de rezolvare.
La b), exact ca la punctul a), am parcurs lista de utilizatori(de data aceasta), am verificat costul transportului si tipul utilizatorului si am adaugat acel utilizator intr-o lista noua.
La c), pentru a converti pointeri de la un tip la altul, am folosit metoda sugerata, si anume, dynamic cast. Astfel, am parcurs lista de produse, am verificat ce tip este produsul, am facut cast-ul dinamic, am verificat motivul "lipsa_accesorii" si am introdus acel produs gasit intr-o lista nonfoodproduct. Apoi, am sortat aceasta lista, folosindu-ma de indicatiile date, si am parcurs aceassta lista de nonfoodproduct si am bagat toate elementele din ea, intr-o alta lista de tip product, pentru a putea sa o returnez. 
La d), similar cu punctul c), m-am folosit de dynamic cast si de data aceasta, iar rezolvarea cerintei a fost aproape identica cu cea de la c).
La e), pentru a gasi judetul cu cei mai multi utilizatori, a trebuit sa fac o metoda noua, ajutatoare, numita 'countRepetition', care imi cauta si imi gaseste judetul care apare de cele mai multe ori si imi returneaza acel judet, ca string.Recunosc ca, aici ma blocasem si a trebuit sa fac un mic research pe stackoverflow pana sa gasesc ce imi trebuie. Am facut asta cu ajutorul unui unordered_map, cu cheia string(numele judetului) si o valoare de tip int, care este, teoretic, pe post de count. Dupa ce s-a gasit judetul cu cele mai multe aparitii, totul a fost relativ simplu de aici. Am rezolvat cerinta parcurgand lista de useri, verificand condtiile cerute si adaugand toti userii gasiti intr-o alta lista nou creata. Am sortat-o in functie de acele criterii si am returnat-o.
La f), din nou, a trebuit sa fac putin research pentru pentru a descoperi cum se sterg dublurile dintr-o lista. Astfel, pentru a rezolva task-ul, a trebuit sa parcurg lista de utilizatori, sa verific care dintre acestia sunt premium, iar apoi am parcurs lista de produse, mapa de discounts si am verificat conditiile cerute. Utilizatorii gasiti i-am adaugat intr-o noua lista. Cand imi gasea un utilizator, apelam break, dupa care contiuam loop-ul. In final, am sters toti utilizatorii care erau la fel din lista pe care trebuia sa o returnez si astfel am rezolvat cerinta. 

4. CERINTA NUMARUL 4-> La LRUCache, a fost similar cu primele cerinte, singura dificultate, sa-i spun asa, a fost la ProcessRequest, dar aceasta mi-a fost lamurita la sedinta de consulatii. Am rezolvat-o parcurgand vectorul dat ca parametru metodei si apoi am introdus toate elementele intr-un nou vector copie, caruia i-am aplicat functia reverse pentru a-mi fi mai usor sa introduc elementele dorite in lru. In final, am returnat lru.

Asadar, am reusit sa implementez aproape toate cerintele, mai putin cea Bonus, pe care sincer, as fi facut-o daca mai aveam timp. Tema a fost de dificultate medie, mai usoara decat prima, dupa parerea mea. Per total, o consider foarte utila pentru a ne consolida tot ceea ce am invatat pana acum la POO.


